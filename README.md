# 동시성 제어 방식에 대한 분석 및 보고서
---

## 동시성 제어란?

동시성은 `Multi-Thread` 환경에서 여러 Thread 가 하나의 공유 자원에 동시에 접근할 때 발생할 수 있는 문제를 제어하는 것이다.

동시성 이라는 키워드를 봤을 때 가장 먼저 떠오른 단어는 `synchronized` 키워드였다. 하지만, 이를 남용하면 block/unblock 처리의 반복으로 어느 정도 시스템 자원이 소모되는 작업이기 때문에 프로그램 성능 저하의 원인이 될 수 있다. 

따라서, 동시성을 보장하며, 병목 현상 최소화와 프로그램 성능을 유지할 수 있는 대안으로 `ConcurrentHashMap` 와 `Reentrant`방법을 선택 했다.

---

## 왜 ConcurrentHashMap과 ReentranctLock 을 함께 사용했을까?

### ConcurrentHashMap만으로 충분하지 않을까?

`ConcurrentHashMap`은 Bucket 단위로 락을 걸어 병렬 처리**를 할 수 있어, 멀티스레드 환경에서 성능 향상에 유리하다.

Bucket이 비어 있는 경우 **CAS(Compare-And-Swap) 방식**으로 Node를 삽입하며, 이는 Non-Blocking 방식으로 효율적이다.

CAS는 특정 메모리 위치 값이 주어진 값과 동일할 경우 새로운 값으로 교체하는 원자적 연산으로, 병렬 환경에서 유용하게 사용된다.

> 예를 들어, 서로 다른 스레드가 같은 Hash Bucket에 접근할 때만 block이 걸리므로, 다른 Bucket에 대한 접근은 병렬로 처리할 수 있다.
> 

하지만 문제가 있다:

- "포인트 조회 → 포인트 사용" 처럼 **순서가 중요한 작업**을 처리할 때는 단일 Bucket 단위 락 만으로는 충분하지 않다.
- 특정 리소스의 배타적 접근(Exclusive-Access)이 필요한 상황에서는 데이터 무결성을 보장하지 못할 수 있다.

### ReentrantLock만으로 충분하지 않을까?

`ReentrantLock`은 단일 리소스에서 배타적 접근과 작업 순서를 보장하는 데 유리하다.

특히, `tryLock, lockInterruptibly`등 세부적인 lock 제어가 가능하다는 점에서 자바의 `synchronized`키워드 보다 유연하다. 

하지만:

- 리소스가 여러 개일 때 모든 리소스를 ReentrantLock으로 관리하면 성능이 떨어질 수 있다.
- 특히, 여러 유저의 포인트 충전/사용 요청을 병렬로 처리해야 하는 경우에는 병목 현상이 발생할 가능성이 크다.

---

## 두 도구를 함께 사용해야 하는 이유

1. `ConcurrentHashMap`을 사용하면 리소스 별로 락을 동적으로 관리할 수 있다.
2. `ReentrantLock`은 특정 리소스에 대해 **순서를 보장**하고 **배타적 접근**을 제어할 수 있다.
3. 두 도구를 조합하면 성능과 데이터 무결성을 모두 충족할 수 있는 구조를 만들 수 있다.

---

## 의문점 및 향후 계획

- **정확한 공정성 보장**
    - `ReentrantLock(true)`을 사용했지만, 락 대기 순서가 100% 보장되지 않는 문제를 확인했다.
    - 이를 보완하기 위해서는 추가적으로 고민해 볼 필요가 있다.
- **락의 해제 타이밍**
    - 특정 스레드가 예외로 인해 작업이 중단되었을 때, 락이 정확히 해제되었는지 확인이 필요하다.
    - 이를 검증하기 위해서는 어떤 테스트 케이스를 추가 해야하는지 고민해 볼 필요가 있다.